 
\documentclass{article}

\title{Algorithm Homework 3}
\author{Rong Yuyang \\ Student ID: 69850764 \\ rongyy@shanghaitech.edu.cn}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[colorlinks,linkcolor=red]{hyperref}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{subfloat}
\newtheorem{prop}{Proposition}
\usepackage{ulem}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}
\begin{document}
\maketitle

\section*{Problem 3-1}
\section*{Problem 3-2}
    \subsection*{(a)}
    By using recursion instead of \textit{find\_min} and \textit{find\_next} can lower the time complexity. In this way, each and every node is only visited once.
\begin{lstlisting}[language = C++]
<template T> T*
  InOrderTraverseBST
  (const Node<T>* node, T* arr){
  if (node == nullptr) { return arr; }
  arr[0] = node->key;
  T* end = InOrderTraverseBST(node->left, arr+1);
  end = InOrderTraverseBST(node->right, end);
  return end;
}
\end{lstlisting}   

    \subsection*{(b)}
\begin{lstlisting}[language = C++]
const bool
  SatisfyBST 
  (const Node* node){
  bool left = true, right = true;
  if (node->left != nullptr) {
    left = ( (node->left->key <= node->key) && SatisfyBST(note->left))
  } 
  if (node->left != nullptr) {
    right = ((node->right->key <= node->key) && SatisfyBST(note->right))
  } 
  return left && right
}
\end{lstlisting}   
\begin{lstlisting}[language = python]
# This one is easier to write in python. Hope you don't mind :)
def SatisfyBST (node):
  if ndoe == None:
    return(True, 0)
  left_sat, left_dep = SatisfyBST(node.left)
  right_sat, right_dep = SatisfyBST(node.right)
  node.depth = max(left_dep, right_dep) + 1
  return (left_sat and right_sat and (abs(left_dep-right_dep) < 2), node.depth)

\end{lstlisting}   
    \subsection*{(c)}
\section*{Problem 3-3}

\end{document}
