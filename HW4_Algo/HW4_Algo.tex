 
\documentclass{article}

\title{Algorithm Homework 4}
\author{Rong Yuyang \\ Student ID: 69850764 \\ rongyy@shanghaitech.edu.cn}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[colorlinks,linkcolor=red]{hyperref}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{subfloat}
\newtheorem{prop}{Proposition}
\usepackage{ulem}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}
\lstset{style=mystyle}
\begin{document}
\maketitle

\section*{Problem 1}
\section*{Problem 2}
\begin{lstlisting}[language = C++]
// Gradient Descent.
double 
  FindMin(
    double (*f)(double), 
    double a, double b){
      /* It's better to compare double based on minus, 
         but let's make our life easier here.*/
      // In case this function goes up and then goes down, 
      // In this case the curr will not change 
      // and min comes from a and b.
      double curr = (f(a) < f(b)) ? a : b;
      double lr = (b-a) / 4;
      double grad, next;
      while (lr >= .00001){
        grad = (f(curr + lr / 128) - f(curr - lr / 128)) / lr * 64;
        next = curr - grad * lr;
        if (f(next) < f(curr)){
          curr = next;
        } else {
          // The next step is larger than here, smaller steps.
          lr *= .75;
        }
      }
      return curr;
}
\end{lstlisting}
\section*{Problem 3}
\begin{lstlisting}[language = C++]
struct Material{
  double w,
  double v,
  double vpw  // Value per Weight,
};
/* Compare based on vpm */
/* Still we assume greater / lesser than is enough to compare double*/
bool operator > (Material a, Material b){
  return (a.vpw > b.vpw);
}
bool operator < (Material a, Material b){
  return (a.vpw < b.vpw);
}
map<Material, double>
  TakeMostValuable(vec<Material> list, double W){
  for (i=list.begin(); i++; i!=list.end()){
    list[i].vpw = v / w;
  }
  // Sort based on vpw in decrease order.
  list.sort_decrease();
  map<Material, double> ans;
  int i = 0;
  // Constantly take valuable objects out and see if it fits.
  while (W > 0){
    Material mat = list[i]
    // If we have room left, put every weight in,
    // Or just put W in and we are done.
    double w = (W>=mat.w) ? mat.w : W
    ans.insert(pair<Material,double>(mat, w));
    W -= w;
    i += 1;
  }
}
\end{lstlisting}
\section*{Problem 4}
\begin{lstlisting}[language = C++]
vec<double>
  FindSets(
    
  )
\end{lstlisting}
\section*{Problem 5}


\end{document}
